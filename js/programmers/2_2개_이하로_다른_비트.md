# 문제 설명

양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.

x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수
예를 들어,

f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

|수|비트|다른 비트의 개수|
|--|--|--|
|2|000...0010||
|3|000...0011|1|

f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

|수|비트|다른 비트의 개수|
|--|--|--|
|7|000...0111||
|8|000...1000|4|
|9|000...1001|3|
|10|000...1010|3|
|11|000...1011|2|

정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

## 제한 사항

- 1 ≤ numbers의 길이 ≤ 100,000
- 0 ≤ numbers의 모든 수 ≤ 10^15

## 입출력 예

|numbers|result|
|--|--|
|[2,7]|[3,11]|

### 설명

입출력 예 #1

문제 예시와 같습니다.

<br />
<br />
<br />

# 풀이

### 사용 언어

Javascript

### 최종 코드

- 규칙을 통해 일반 반복문으로 해결
    - 짝수, 홀수를 구분
    - 짝수일 때는 자릿수가 변경되지 않고 맨 뒤 숫자만 변경
    - 홀수일 때는 자릿수 변경이 필수이기 때문에 해당 값만 변경해주면 됨

```
function solution(numbers) {
    return numbers.map((number) => {
        let s = '0'+number.toString(2);
        
        if (s[s.length - 1] === '0') {
            s = s.substring(0, s.length - 1) + '1';
        } else {
            const idx = s.lastIndexOf('01');
            s = s.substring(0, idx) + '10' + s.substring(idx + 2, s.length)
        }
        
        return parseInt(s, 2)
    })
}

```

## 참고
[[프로그래머스 Lv.2] 2개 이하로 다른 비트 (js)
](https://parkparkpark.tistory.com/103)