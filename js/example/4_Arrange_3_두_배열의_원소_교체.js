const [N, K] = [5, 3];
const arr1 = [1, 2, 5, 4, 3];
const arr2 = [5, 5, 6, 6, 5];

arr1.sort((a, b) => a - b);
arr2.sort((a, b) => b - a);

for (let i = 0; i < K; i++) {
  const tmp = arr1[i];
  arr1[i] = arr2[i];
  arr2[i] = tmp;
}

console.log(arr1.reduce((acc, cur) => acc + cur));

/**
 * 
 * 이 코드에서 `N`이 커질 때 발생할 수 있는 주요 이슈는 **메모리 초과(Memory Overflow)** 또는 **실행 시간 초과(Time Limit Exceeded, TLE)**입니다.  
자바스크립트는 브라우저 환경과 Node.js 환경에서 동작하며, 배열 크기에 대한 제한이 달라질 수 있습니다.

---

### 1. **메모리 한계**  
자바스크립트의 `Array`는 동적 배열이며, 최대 크기는 V8 엔진(Node.js 및 Chrome 기반)에서 약 **2³² - 1(약 4.29 billion, 43억 개)** 개의 요소를 저장할 수 있습니다.  
하지만, 현실적으로 **메모리(RAM) 제한** 때문에 `N`이 너무 크면 프로그램이 **메모리 부족(Out of Memory, OOM)** 에러를 일으킬 수 있습니다.

보수적으로 예상해 보면:
- 배열 `arr1`, `arr2`는 각각 `N` 크기의 요소를 저장함.
- 각 요소는 `Number` 타입(약 8바이트)으로 저장됨.
- 그러므로 배열 하나당 **약 `8N` 바이트**의 메모리를 사용.
- 두 개의 배열이므로 **총 `16N` 바이트**의 메모리 필요.

> 예를 들어, `N = 10⁷ (1천만)`이면:
> - `16 * 10⁷ = 160MB` 정도의 메모리 사용  
> - 충분히 실행 가능하지만, `N`이 `10⁸ (1억)`을 넘어가면 약 **1.6GB**가 필요하여 메모리 부족이 발생할 가능성이 큼.

---

### 2. **실행 시간 한계**  
배열을 정렬하는 `arr1.sort((a, b) => a - b)`와 `arr2.sort((a, b) => b - a)`는 **O(N log N)**의 시간 복잡도를 가집니다.  
이후 반복문 `for (let i = 0; i < K; i++)`는 **O(K)** 연산이 추가로 필요합니다.

- 현실적으로 `N log N` 연산은 `N ≈ 10⁷` 정도까지는 문제없이 실행됨.  
- 하지만 `N ≈ 10⁸`을 넘어가면 정렬하는 데 **수 초 이상** 걸릴 수 있으며,  
  실행 환경에 따라 **TLE(시간 초과)**가 발생할 수도 있음.

---

### 3. **결론**  
1. **메모리 한계:**  
   - `N ≈ 10⁸ (1억)` 이상이면 **메모리 초과(OOM)** 가능성 높음.  
   - 일반적인 시스템(8GB RAM)에서는 `N ≈ 10⁷ (천만)` 정도까지 안전.

2. **실행 시간 한계:**  
   - `N ≈ 10⁷ (천만)`까지는 문제없이 실행될 가능성이 큼.  
   - `N ≈ 10⁸ (1억)` 이상이면 정렬 과정에서 **시간 초과(TLE)** 발생 가능.

**안전한 범위:**  
일반적인 환경에서는 `N ≈ 10⁶ ~ 10⁷` 정도까지는 문제없이 동작할 확률이 높음.  
하지만 `N ≈ 10⁸`을 넘어가면 **실행 속도나 메모리 문제로 인해 오류 발생 가능성**이 큼.
 */